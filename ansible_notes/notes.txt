SOP:Standard operating procedure

1. all automations should run in GOCD
2. all the automation on OS will be Ansible
3. all infra automation with terraform

* frontend connects backend through conf file
* conf  file contains backend localhost to connect from frontend to backend
mysql:
=====
mysql: to excecute sql queries on my sql server.
so we need to install my sql server.

backend:
========

dnf module list---to list modules
A daemon user is an account on the system under which a particular application is meant to run,
thereby restricting access, etc. for that specific use-case

should know mysql server vs mysql
commands:
=========
sudo dnf install ansible
sudo pip3.11 install ansible

mysql_secure_installation is basically just a couple of SQL commands to make MySQL more secure.

to lookup dns records use command "nslookup frontend.abc72.online"
 to search any package:
 ======================
* dnf list | grep MYSQL-python
* pip3.11 list ---to know the list of pacakges
* ansible-playbook -i localhost, -e ansible-user="" -e ansible_password = "" -m ping -vv
pip3.9 install PYMYSQL
pip3.9 install Cryptography

3 steps:
========
1.keep the code DRY
2.username and password should not be there
3.re-run should not fail

to declare variables in three ways:
===================================
play role
task role

- name: variables
  hosts: localhost
  vars:
    url_play: play.com
  tasks:
    - name: playlevle
      ansible.builtin.debug:
        msg: url_play--{{url_play}}

    - name: itself
      ansible.builtin.debug:
        msg: local_var---{{local_var}}
      vars:
        local_var: example.com

role level variable:
===================
declare vars under roles--->commmon--->vars--->main.yml
under main.yml

 - name: playlevle
   ansible.builtin.debug:
     msg: Hello

  - name: playlevle
    ansible.builtin.debug:
      msg: url_play--{{url_play}}

      url_play --value pass through command line

if there is a key and value ,the dynamic value should keep in double quotes with flower brackets
ex: value: "{{url_role}}"


to follow ansible role structure:
=================================
roles
---------->frontend
           -------------->tasks----->main.yml
           --------------->vars----->main.yml
           --------------->common---->tasks---->main.yml

should write in tasks,main.yml only tasks level code
frontend.yml
------------
- name: frontend appl
  hosts:all
  become: true
  roles:
    "{{role_name}}"

rest backend,mysql is same

keep the code DRY: means common code in every yml file under role keep in one folder.....

keep the code under common ---> tasks ----> main.yml
import this common code where required
(search import role)
- name: Import code commonly
  ansible.builtin.import_role:
    name: common
    tasks_from: pre-req.yml

    in the above code......
    name is a key and common is a directory under roles where we keep common code
    tasks_from is a key and pre-req.yml is a file


calling the role from frontend.yml and control goes to frontend folder under roles.

How to run ansible in multi environment?
like dev,prod,....
when we run the application in "dev" environment ,need to copy the expense.conf file in dev env...
so , dynamicallly,copy module will not able to copy the expense.conf file . so here we use template modules

* copy module will work for static data , to copy from src to dest file
* template module will work for dynamic text data , to copy the text content from src to dest file dynamically
ansible-playbook -i localhost, -e ansible_user="" -e ansible_pass="" env=dev frontend.yml
* Role dependencies are always executed before the role that includes them, and may be recursive.
* Role dependencies are prerequisites
Ansible loads all listed roles but role dependencies loads first then other roles will execute....
* Role dependencies are stored in the meta/main.yml file within the role directory.
under frontend folder
dependencies:
  - role: common

here common is a folder under roles
common/tasks/main.yml
===========
- name: set sudo prompt
  ansible.builtin.shell: set-prompt frontend



in exepnse.conf: proxy_pass http://frontend-dev.abcdevops.online:8080
here dev is a static
proxy_pass http://frontend-{{env}}.abcdevops.online:8080
here env to pass  dynamic(like env=dev)---for this code templates module came into the picture.....
ansible-playbook -i localhost, -e ansible_user=ec2-user -e ansible_password=DevOps321 env=dev frontend.yml


no need to write duplicate roles in each and every yml file....
like
frontend.yml
=============
- name:
  hosts:
  become:
  roles:
    - frontend

in the above code to pass the roles dynamically instead of static
playbook.yml
=============
 -name:
  hosts:
  become:
  roles:
   - {{role_name}}

how to run ansible roles in linux?
ansible-playbook -i localhost, playbook.yml -e ansible_user=ec2-user -e ansible_password = DevOps321 role_name=frontend

then ansible controls move to playbook.yml file there assign "frontend"  to the role .
then  control goes to frontend folder in roles.it will applicable for rest roles(backend,mysql)


Ansible certification exam:
============================
1.Inventory:
The Ansible inventory file defines the hosts and groups of hosts upon which commands,
modules, and tasks in a playbook operate.(-i localhost)
2.Environment:
Ansible Environment variables are used to set the environment variable for action on the remote host
using the environment keyword.(env=dev)
3.Plays vs Playbooks
playbooks:collection of plays
Playbooks are collections of one or more plays that are performed in a certain order.(under roles)
A play is an ordered sequence of tasks performed against hosts from your inventory. (frontend--->task---->main.yml)
to run a specific play
ansible-playbook -i localhost, playbook.yml -e ansible_user=ec2-user -e ansible_password = DevOps321 role_name=frontend
4.configuration in ansible:
$ ansible-config init --disabled > ansible.cfg---to generate config files
5.adhoc commands:
- m ping
- m command
-m group
Use variables to retrieve the results of running commands
=========================================================
6.store result of task in output variable
 - name: store result of task
   ansible.builtin.shell: uptime
   //here uptime is a builtin variable
   register: output
   here register is a key to store the task value into a variable

retrieve the result of task
- name: retreive the result of task
  ansible.builtin.debug:
    msg: {{output}}

* sudo dnf install jq -y
The jq command in Linux is a versatile tool that allows you to parse and manipulate JSON
data right from your command line.
to check proper json or not.
cat /tmp/1.json | jq
here 1.json is a file to store json data
cat /tmp/1.json | jq '.failed'
through ansible
msg: {{output.failed}}
for each and every module in ansible , json data is different

7.Use conditionals to control play execution
"when"
- name: arithmetic
  ansible.builtin.debug:
    msg: add
  when type == add

- name: operator
  ansible.builtin.debug:
    msg: sub
  when type == sub

to run on linux:
anisble-playbook var.yml type = add

Scenario:
In backend already db credentials are available.again repeated in mysql
so get the sql info "mysql.mysql_db" (backend)
In mysql we are having mysql error like "mysql-secure installation"
* first get the sql info and then write the condition based on jq (json)


8.configure error handling:
===========================
if a task is failure ,but the execution should not stop,then use "ignore_errors"

9.create playbooks to configure systems to a specified state:
=================================================================
10.create and use templates to create customized configuration files:yes(need to search)
11.work with ansible variables and facts:yes
12.create and work with roles:yes
13.ansible galaxy
14:ansible vaults: vaults supports only ansible not integrate to other tools.
===============================================================================
* ansible-vault--enter
to encrypt the string :ansible-vault encrypt_string abc@123
then it will ask "new vault  password" "confirm vault password"
then displays vault encryped password...
copy vault password and paste in play level vars
decrypt vault:
to run vault through yml file, use "ansible-playbook abc.yml --ask-vault-password"
to encrypt yml file
* ansible-vault encrypt abc.yml
to decrypt yml file
* ansible-vault decrypt abc.yml

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Loops in ansible:
=================
msg: "fruitname - {{item}}-{{quantity}}"
loop:
-{name:apple,quantity:1}
-{name:mango,quantity:5}
-{name:grapes,quantity:8}
here item pick every time one by one

ansible-filters:
----------------
msg:yes you need to install
when: installed | bool
instead of bool it will take string

depolyment tool:
================
through automation we can deliver the application
continuous deployment should not take
continuous delivery:should take(to make everything to automate)

GOCD : running the jobs is nothing but running ansible.
gocd server: is a server to manage the jobs
gocd agent: to run actual tasks
In the GoCD ecosystem, the server is the one that controls everything. It provides the user interface to users of the system and provides work for the agents to do. The agents are the ones that do any work (run commands, do deployments, etc) that is configured by the users or administrators of the system.

The server does not do any user-specified "work" on its own. It will not run any commands or do deployments. That is the reason you need a GoCD Server and at least one GoCD Agent installed before you proceed.

pipelines:
===========
to run the jobs and deploy in test environment.
to run the jobs in two ways:
through automation
through manual(ui)
tomzo gocd yaml configuration:reference for gocd
** bash ansible.sh frontend
bash(command) ansible.sh(shell script --arguments)  frontend(arguments)
in pipelines code "undet task section -->exec--->pass arguments"
- ansible.sh(shell script)
- frontend
command: bash

to run through bash command instead of linux server:
=====================================================
ansible.sh:
============
component=$1
env(it is a command)
bash ansible.sh frontend:command
in the above command frontend is a $1(component)
ansible-playbook -i localhost, playbook.yml  -e role_name=frontend  -e env=dev -e ansible_user=ec2-user -e ansible_password=DevOps321
Environment:
Environment variables can be declared in Environments, Pipelines, Stages and Jobs.
stages:
====
environment_variables:
TEST_NUM: 1

* not declared environement variables in stage ,job level then we can use another approach
ansible-playbook -i localhost, playbook.yml  -e role_name=frontend  -e env=$env -e ansible_user=ec2-user -e ansible_password=DevOps321
SOP:
====
* All automations should run in GOCD
* All automation on OS will be ansible

By default ansible is a push mechanishm
Ansible pull:
=============
* Server is connected with nodes through SSH so that it can push code to nodes. (runs in linux)
* Ansible-pull is a command line tool that fetches a playbook from a git server and runs it locally-----(gocdserver)
pulls playbooks from a VCS repo and executes them on target host.
to get yml file from girt reop through git url and runs in the hosts(either localhost,different ip address)

pending topics practice:
========================
register: mysql----complete
Ignore_errors:mysql---complete
ansible.sh----complete
pipelines:gocd
env command
instead env

errors: my conf root
solution: not connected to proper hosts.(either reorder the code or check once...)

"use frontend host to connect React App"(to connect application)
any changes in schema : restart service in linux server




